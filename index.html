<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="聆听群山的怒号">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="聆听群山的怒号">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="聆听群山的怒号">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>聆听群山的怒号</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">聆听群山的怒号</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/24/『译』在 vue 中使用各种各样的 javascript 库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fszer">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://cloud.githubusercontent.com/assets/18730194/15146790/dd39acee-16ef-11e6-8ee7-093d1ce74fce.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="聆听群山的怒号">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/24/『译』在 vue 中使用各种各样的 javascript 库/" itemprop="url">
                  【译】在 vue 中使用各种各样的 javascript 库
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-24T19:20:43+08:00">
                2017-08-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Use-Any-Javascript-Library-With-Vue-js-–-Vue-js-Developers-–-Medium"><a href="#Use-Any-Javascript-Library-With-Vue-js-–-Vue-js-Developers-–-Medium" class="headerlink" title="Use Any Javascript Library With Vue.js – Vue.js Developers – Medium"></a>Use Any Javascript Library With Vue.js – Vue.js Developers – Medium</h1><p><img src="http://p0.qhimg.com/t01f84276a74709377e.jpg" alt=""></p>
<p>Lodash, Moment, Axios, Async…these are useful Javascript libraries that you’ll want to utilise in many of your Vue.js apps.</p>
<p>Lodash, Moment, Axios, Async…这些都是非常有用的 Javascript 库，而且你会希望在你的各种 Vue.js 应用之中使用。</p>
<p>But as your project grows you’ll be separating code into single file components and module files. You also may want to run your app in different environments to allow server rendering.</p>
<p>但是随着你的项目的增长，你会想要将代码分离为单一的组件文件跟模块文件。同时，你可能也会想要让你的应用能运行在不同的环境下，比如可以通过服务端渲染。</p>
<p>Unless you find an easy and robust way to include those Javascript libraries across your components and module files they’re going to be a nuisance!</p>
<p>除非你找到一个简单且健壮的方法去引入这些 Javascript 库到你的组件文件与模块文件中，不然他们将会成为你项目中的一个累赘！</p>
<p><em>Note: this article was originally posted</em> <a href="http://vuejsdevelopers.com/2017/04/22/vue-js-libraries-plugins/?jsdojo_id=medium_lip" target="_blank" rel="external"><em>here on the Vue.js Developers blog</em></a> <em>on 2017/04/22</em></p>
<p>_注意:这篇文章原载于<a href="http://vuejsdevelopers.com/2017/04/22/vue-js-libraries-plugins/?jsdojo_id=medium_lip" target="_blank" rel="external">the Vue.js Developers blog</a> 2017/04/22_</p>
<h3 id="How-to-include-a-library-in-a-Vue-js-project"><a href="#How-to-include-a-library-in-a-Vue-js-project" class="headerlink" title="How to include a library in a Vue.js project"></a>How to include a library in a Vue.js project</h3><h2 id="如何引入一个类库到你的-Vue-js-项目中"><a href="#如何引入一个类库到你的-Vue-js-项目中" class="headerlink" title="如何引入一个类库到你的 Vue.js 项目中"></a>如何引入一个类库到你的 Vue.js 项目中</h2><h3 id="Global-variable"><a href="#Global-variable" class="headerlink" title="Global variable"></a>Global variable</h3><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>最直接添加一个类库到你的项目中的方法，是让这个类库作为一个全局变量挂载在 <code>window</code> 对象上<br>The naive way to add a library to your project is to make it a global variable by attaching it to the <code>window</code> object:</p>
<p><strong>entry.js</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>._ = <span class="built_in">require</span>(<span class="string">'lodash'</span>);</div></pre></td></tr></table></figure></p>
<p><strong>MyComponent.vue</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  created() &#123;</div><div class="line">    <span class="built_in">console</span>.log(_.isEmpty() ? <span class="string">'Lodash everywhere!'</span> : <span class="string">'Uh oh..'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>关于反对 window 全局变量是一个十分悠久的话题，但是，在具体到这篇文章中，是因为这样不支持服务器渲染，当这个应用跑在服务端，<code>window</code> 对象将不复存在，因此会导致尝试访问这个原型的时候会抛出一个错误并终止它。<br>The case against window variables is a long one, but, specifically to this discussion, they don’t work with server rendering. When the app runs on the server the <code>window</code> object will be undefined and so attempting to access a property will end with an error.</p>
<h3 id="Importing-in-every-file"><a href="#Importing-in-every-file" class="headerlink" title="Importing in every file"></a>Importing in every file</h3><h3 id="引入到每个文件中"><a href="#引入到每个文件中" class="headerlink" title="引入到每个文件中"></a>引入到每个文件中</h3><p>另一个二流方法是在每一个文件中都把类库文件引入进去。<br>Another second-rate method is to import the library into every file:</p>
<p><strong>MyComponent.vue</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'lodash'</span>;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  created() &#123;</div><div class="line">    <span class="built_in">console</span>.log(_.isEmpty() ? <span class="string">'Lodash is available here!'</span> : <span class="string">'Uh oh..'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这当然行得通，然而这并不 DRY 并且这基本上就是一种惩罚游戏：你不得不记住要在每个文件中都引入这些些类库，以及当你不再需要使用它以后也要记得移除它。<br>与此同时，如果你没有正确的设置好你的构建工具，你很有可能会在你最终构建出来的文件中会有一个类库的多个副本在其中。<br>This works, but it’s not very DRY and it’s basically just a pain: you have to remember to import it into every file, and remove it again if you stop using it in that file. And if you don’t setup your build tool correctly you may end up with multiple copies of the same library in your build.</p>
<h3 id="A-better-way"><a href="#A-better-way" class="headerlink" title="A better way"></a>A better way</h3><h3 id="一个更好的解决方案"><a href="#一个更好的解决方案" class="headerlink" title="一个更好的解决方案"></a>一个更好的解决方案</h3><p>在 Vue 项目中使用一个 Javascript 库的最干净且最健壮的方法是将他代理为 Vue 原型对象的属性。<br>让我们来试试通过这种方式把 Moment date 和 time 库添加到我们的项目中来：<br>The cleanest and most robust way to use a Javascript library in a Vue project is to proxy it to a property of the Vue prototype object. Let’s do that to add the Moment date and time library to our project:</p>
<p><strong>entry.js</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> moment <span class="keyword">from</span> <span class="string">'moment'</span>;</div><div class="line"><span class="built_in">Object</span>.definePrototype(Vue.prototype, <span class="string">'$moment'</span>, &#123; value: moment &#125;);</div></pre></td></tr></table></figure></p>
<p>由于所有的组件都会从 Vue 原型对象中继承其所有方法，这让 Moment 自然而然的传递到任何或者说所有的组件当中，并且无需全局变量或者是手动引入什么东西（到组件中）。<br>只通过 <code>this.$moment</code> 就可以在任意的实例/组件中快速简单地访问到 Moment</p>
<p>Since all components inherit their methods from the Vue prototype object this will make Moment automatically available across any and all components with no global variables or anything to manually import. It can simply be accessed in any instance/component from <code>this.$moment</code>:</p>
<p><strong>MyNewComponent.vue</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  created() &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'The time is '</span> . this.$moment().format(<span class="string">"HH:mm"</span>));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在，让我们花点时间来搞清楚这是为什么。<br>Let’s take the time now to understand how this works.</p>
<h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h3><p>我们通常会这样设置一个对象属性：<br>We would normally set an object property like this:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Vue.prototype.$moment = moment;</div></pre></td></tr></table></figure>
<p>在这个示例中你确实可以这样做，但如果用<code>Object.defineProperty</code>来定义，我们就可以同时定义属性的<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="external">描述符</a>。描述符允许我们设置一些底层的细节信息，例如我们的属性是否是可写的，又或者是循环中是否是可枚举的等等。</p>
<p>You could do that here, but by using <code>Object.defineProperty</code> instead we are able to define our property with a <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="external">descriptor</a>. A descriptor allows us to set some low-level details such as whether or not our property is writeable and whether it shows up during enumeration in a <code>for</code> loop and more.</p>
<p>我们通常不会对此感兴趣，因为在我们日复一日的 Javascript 时间里，其中 99% 的时间我们都不需要了解属性赋值的这一低层级细节信息。<br>不过在这里它可以给我们明显的好处：通过描述符去创建的属性默认是<em>只读的</em>。</p>
<p>We don’t normally bother with this in our day-to-day Javascript because 99% of the time we don’t need that level of detail with a property assignment. But here it gives us a distinct advantage: properties created with a descriptor are <em>read-only</em> by default.</p>
<p>这意味着那些一时失了智的开发者（或者就是你自己）不会有机会干出一些类似下面这个组件中那样的蠢事，进而搞坏整锅粥。<br>This means that some coffee-deprived developer (probably you) won’t be able to do something silly like this in a component and break everything:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.$http = <span class="string">'Assign some random thing to the instance method'</span>;</div><div class="line"><span class="keyword">this</span>.$http.get(<span class="string">'/'</span>); <span class="comment">// TypeError: this.$http.get is not a function</span></div></pre></td></tr></table></figure>
<p>相对的，我们的只读实例方法保护了我们的类库不被修改，假如你尝试去重写它，你就只会得到一个“TypeError: Cannot assign to read only property”。<br>Instead, our read-only instance method protects our library, and if you attempt to overwrite it you will get “TypeError: Cannot assign to read only property”.</p>
<h3 id=""><a href="#" class="headerlink" title="$"></a>$</h3><p>你应该会注意到代理我们的类库到一个属性上的时候，属性名前补充了一个美元符号“$”的前缀。你也大概已经见过其他一些属性或者方法比如 <code>$refs</code>,<code>$on</code>,<code>$mount</code> 等等也都有同样的前缀。<br>You’ll notice that we proxy our library to a property name prefixed with the dollar sign “$”. You’ve probably also seen other properties and methods like <code>$refs</code>, <code>$on</code>, <code>$mount</code> etc which have this prefix too.</p>
<p>虽然不是必须的，这个前缀加到这些属性上也是为了提醒那些失了智的开发者（不用看，还是你），这是一个公共 API 属性或者方法，欢迎使用，不像其他的实例属性可能只是给 Vue 的内部使用。</p>
<p>While not required, the prefix is added to properties to remind coffee-deprived developers (you, again) that this is a public API property or method that you’re welcome to use, unlike other properties of the instance that are probably just for Vue’s internal use.</p>
<p>作为一个基于原型链的语言，Javascript 没有（真正意义上的）类，因此也没有所谓的 “私有” 和 “公共” 变量或者是 “静态” 方法。<br>而这种（$ 符号）约定俗成实际上是一种柔和的提醒，我认为这是值得去遵循的。<br>Being a prototype-based language, there are no (real) classes in Javascript so it doesn’t have “private” and “public” variables or “static” methods. This convention is a mild substitute which I think is worthwhile to follow.</p>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>由于类库现在是一个实例方法，所以通过 <code>this.libraryName</code> 来使用类库不会是一件值得惊讶的事。<br>You’ll also notice that to use the library you use <code>this.libraryName</code> which is probably not a surprise since it is now an instance method.</p>
<p>这样做的一个后果是，与使用全局变量不一样，你必须确保使用类库时处于一个正确的作用于中。<br>比如在内部回调函数中你就不能访问的到 <code>this</code> 上的类库。<br>One consequence of this, though, is that unlike a global variable you must ensure you’re in the correct scope when using your library. Inside callback methods you can’t access the <code>this</code> that your library inhabits.</p>
<p>对此，箭头回调函数会是一个不错的解决方案，它会确保你在正确的作用域中<br>Fat arrow callbacks are a good solution to making sure you stay in the right scope:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.$http.get(<span class="string">'/'</span>).then(res =&gt; &#123;</div><div class="line">  <span class="keyword">if</span> (res.status !== <span class="number">200</span>) &#123;</div><div class="line">    <span class="keyword">this</span>.$http.get(<span class="string">'/'</span>) <span class="comment">// etc</span></div><div class="line">    <span class="comment">// Only works in a fat arrow callback.</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="Why-not-make-it-a-plugin"><a href="#Why-not-make-it-a-plugin" class="headerlink" title="Why not make it a plugin?"></a>Why not make it a plugin?</h3><h3 id="为什么不把它作为一个插件呢？"><a href="#为什么不把它作为一个插件呢？" class="headerlink" title="为什么不把它作为一个插件呢？"></a>为什么不把它作为一个插件呢？</h3><p>如果你计划在多个 Vue 项目中使用同一个类库，又或者你想要把它分享给全世界，那么你其实可以去构建一个属于你自己的插件。<br>If you’re planning to use a library across many Vue projects, or you want to share it with the world, you can build this into your own plugin!</p>
<p>一个插件可以把复杂的操作抽象出来，从而允许你通过如下面所展示，十分简单的方式去把你所选的类库添加到一个项目中。<br>A plugin abstracts complexity and allows you to simply do the following in a project to add your chosen library:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> MyLibraryPlugin <span class="keyword">from</span> <span class="string">'my-library-plugin'</span>;</div><div class="line">Vue.use(MyLibraryPlugin);</div></pre></td></tr></table></figure></p>
<p>仅靠这样两行代码，我们就可以在任意的组件中使用我们的类库，就像我们使用 Vue Router，Vuex 又或者其他可以通过 <code>Vue.use</code> 使用的插件那样。<br>With these two lines we can use the library in any component just like we can with Vue Router, Vuex and other plugins that utilise <code>Vue.use</code>.</p>
<h3 id="Writing-a-plugin"><a href="#Writing-a-plugin" class="headerlink" title="Writing a plugin"></a>Writing a plugin</h3><h3 id="写一个插件"><a href="#写一个插件" class="headerlink" title="写一个插件"></a>写一个插件</h3><p>首先，为你的插件创建一个文件。在这个例子中我将会写一个把 Axios 添加到你所有的 Vue 示例和组件的插件，因此我将文件命名为 <em>axios.js</em>。<br>Firstly, create a file for your plugin. In this example I’ll make a plugin that adds Axios to your all your Vue instances and components, so I’ll call the file <em>axios.js</em>.</p>
<p>其中最需要搞清的事情是，插件需要暴露一个 <code>install</code> 方法，该方法中会将 Vue 的构造函数作为第一个参数。<br>The main thing to understand is that a plugin must expose an <code>install</code> method which takes the Vue constructor as the first argument:</p>
<p><strong>axios.js</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  install: <span class="function"><span class="keyword">function</span>(<span class="params">Vue</span>) </span>&#123;</div><div class="line">    <span class="comment">// Do stuff</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在我们可以使用我们私有的方法去把类库添加到原型对象:<br>Now we can use our previos method to add the library to the prototype object:</p>
<p><strong>axios.js</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  install: <span class="function"><span class="keyword">function</span>(<span class="params">Vue,</span>) </span>&#123;</div><div class="line">    <span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">'$http'</span>, &#123; value: axios &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于添加类库到一个项目中作业这个目标来说，<code>use</code> 这个实例方法就是我们现在所需要知道的一切。<br>举个例子，要把 Axios 添加到项目中，我们只需要像下面那样容易操作：<br>The <code>use</code> instance method is all we now need to add our library to a project. For example, we can now add the Axios library as easily as this:</p>
<p><strong>entry.js</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> AxiosPlugin <span class="keyword">from</span> <span class="string">'./axios.js'</span>;</div><div class="line">Vue.use(AxiosPlugin);</div><div class="line"></div><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  created() &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$http ? <span class="string">'Axios works!'</span> : <span class="string">'Uh oh..'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="Bonus-plugin-optional-arguments"><a href="#Bonus-plugin-optional-arguments" class="headerlink" title="Bonus: plugin optional arguments"></a>Bonus: plugin optional arguments</h3><h3 id="砰-插件的可选参数"><a href="#砰-插件的可选参数" class="headerlink" title="砰: 插件的可选参数"></a>砰: 插件的可选参数</h3><p>你的插件的 install 方法还可以带上可选参数。一些开发者可能不会喜欢命名他们的 Axios 实例方法为 <code>$http</code> ,这是由于 Vue Resource 通常会使用这个名字,<br>那么，让我们通过可选参数来允许他们可以改用任何他们喜欢的名字吧：</p>
<p>Your plugin install method can take optional arguments. Some devs might not like calling their Axios instance method <code>$http</code> since Vue Resource is commonly given that name, so let’s use an optional argument to allow them to change it to whatever they like:</p>
<p><strong>axios.js</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  install: <span class="function"><span class="keyword">function</span>(<span class="params">Vue, name = '$http'</span>) </span>&#123;</div><div class="line">    <span class="built_in">Object</span>.defineProperty(Vue.prototype, name, &#123; value: axios &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>entry.js</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> AxiosPlugin <span class="keyword">from</span> <span class="string">'./axios.js'</span>;</div><div class="line">Vue.use(AxiosPlugin, <span class="string">'$axios'</span>);</div><div class="line"></div><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  created() &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$axios ? <span class="string">'Axios works!'</span> : <span class="string">'Uh oh..'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<hr>
<p><em>获得最新的 Vue.js 文章，教程和最棒的项目，都在这里</em> <a href="http://vuejsdevelopers.com/newsletter/?jsdojo_id=medium_lip" target="_blank" rel="external"><em>Vue.js Developers Newsletter</em></a></p>
<ul>
<li><p><a href="https://medium.com/tag/javascript?source=post" target="_blank" rel="external">JavaScript</a></p>
</li>
<li><p><a href="https://medium.com/tag/vue?source=post" target="_blank" rel="external">Vue</a></p>
</li>
<li><p><a href="https://medium.com/tag/vuejs?source=post" target="_blank" rel="external">Vuejs</a></p>
</li>
<li><p><a href="https://medium.com/tag/web-development?source=post" target="_blank" rel="external">Web Development</a></p>
</li>
<li><p><a href="https://medium.com/tag/front-end-development?source=post" target="_blank" rel="external">Front End Development</a></p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/13/声明式弹出层的问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fszer">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://cloud.githubusercontent.com/assets/18730194/15146790/dd39acee-16ef-11e6-8ee7-093d1ce74fce.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="聆听群山的怒号">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/13/声明式弹出层的问题/" itemprop="url">
                  声明式弹窗的弊端
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-13T23:53:02+08:00">
                2017-08-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>虽然 vue 非常宣扬其组件封装的模式，然而因为 dom 本身的一些限制与问题， vue 的组件模式在某些时候也并不是最佳的做法。<br>其中，前端常见的弹窗，弹出层式的组件，就是一个例子，vue 的组件模式在此时就会出现明显的问题。<br>这次要讨论的就是声明式的弹窗存在的问题及其解决方法。</p>
<h2 id="声明式弹出层弊端"><a href="#声明式弹出层弊端" class="headerlink" title="声明式弹出层弊端"></a>声明式弹出层弊端</h2><h3 id="弹窗与弹出层"><a href="#弹窗与弹出层" class="headerlink" title="弹窗与弹出层"></a>弹窗与弹出层</h3><p>在前端项目中，弹窗是一种相当频繁的组件，自不必细说，而相似的，弹出层这个东西也十分有用。<br>比如选中 select 之后弹出的选择列表， 比如 tooltip ，dropdown 这样的组件多多少少都可以抽象为这样或那样的弹出层组件。</p>
<p>之所以提到 select ，是因为最近遇到一个需求，需要统一各个浏览器的 select 下拉样式，<br>而 select 的原生下拉部分无法直接定义样式，就只能通过一个弹出层模拟下拉这样，这是促使我敲下这篇文章的原因之一。</p>
<h3 id="vue-组件结构下的一般弹出层模式"><a href="#vue-组件结构下的一般弹出层模式" class="headerlink" title="vue 组件结构下的一般弹出层模式"></a>vue 组件结构下的一般弹出层模式</h3><p>现在我们已经解了我们需要怎么样的组件，不过还不到吐槽的时候，<br>接下来我们还得再说说 vue 组件结构下如何处理这样的组件，才能更好的展现问题的所在。</p>
<p>让我们先忽略 modal 的具体实现，所谓的声明式组件，使用起来大概是这样的</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">'open=!open'</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">modal</span> <span class="attr">v-show</span>=<span class="string">'open'</span>&gt;</span></div><div class="line">    modal-content...</div><div class="line">  <span class="tag">&lt;/<span class="name">modal</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div></pre></td></tr></table></figure>
<p>声明式的组件会预先就写在了模板当中，然后我们其实只需要控制 open 的状态就可以达到控制 modal 的显示/隐藏效果，<br>我们是预先<strong>声明</strong>了一个 modal 的组件，而非通过 js 动态的创建插入组件<br>这样是 vue 所倡导的一种将组件的变换映射到状态的切换以达到一个更清晰的控制模式。</p>
<p>另一方面 对于 select 组件的实现，我们可能会想到这样子</p>
<p>将一个 input 与 一个弹出层 <code>dropdown-list</code> 作为下拉列表放到一起，然后将各种选择事件，交互效果联系起来</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'select'</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">'value'</span>&gt;</span>    </div><div class="line">    <span class="tag">&lt;<span class="name">dropdown-list</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">select-item</span>&gt;</span>.....<span class="tag">&lt;/<span class="name">select-item</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dropdown-list</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="带来的问题"><a href="#带来的问题" class="headerlink" title="带来的问题"></a>带来的问题</h3><p>如果你了解一些 vue 的话，其实我上面的这两段东西都是十分普通，甚至初级的东西，<br>如果是一般的组件其实这样的使用与组合方式是没有什么问题的。 </p>
<p>但是实际上他们还是会有不少问题的……</p>
<h4 id="复杂dom结构下的尴尬"><a href="#复杂dom结构下的尴尬" class="headerlink" title="复杂dom结构下的尴尬"></a>复杂dom结构下的尴尬</h4><p>首先一个跟 html 本身有关，上文中的 <code>dropdown-list</code>,<br>为了更接近原生的 select， <code>dropdown-list</code> 实际上会是绝对定位的一个『弹出层』，堆叠于其他 html 之上。</p>
<p>这在一般情况并没有什么问题，但如果我们上面定义的 select 组件使用在一个带有 overflow 为 hidden 的父组件中，</p>
<p>并且我们的 select 组件比较靠近边缘，那么我们的绝对定位的 <code>dropdown-list</code> 就会被 overflow 为 hidden 的父组件所遮蔽。</p>
<p>在日常的项目中，我们显然很难保证一定不会出现这种布局，不仅是我所展示的 select，那些需要绝对定位结构的组件都会遇到这个问题。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">'overflow:hidden'</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">select</span>&gt;</span><span class="tag">&lt;/<span class="name">select</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>又比如 modal 的问题，在 modal 中我们虽然会用 fixed 来相对于浏览器窗口固定，这个时候虽然不会因为 overflow hidden 而被隐藏，<br>但是依然有可能因为父组件有一些特殊的样式而产生错乱，比如<br><a href="http://www.zhangxinxu.com/wordpress/2015/05/css3-transform-affect/" target="_blank" rel="external">transform限制position:fixed的跟随效果</a></p>
<p>总的来说，在复杂的 dom 结构中，我们可能会在一个非常深的地方使用到一些需要绝对定位的组件，这个时候我们的组件不可避免的可能会受到父组件的样式影响。</p>
<h4 id="中间状态的处理"><a href="#中间状态的处理" class="headerlink" title="中间状态的处理"></a>中间状态的处理</h4><p>接着是关于 vue 将 modal 交互变化映射到状态的变化的讨论，比如我们 modal 如果仅仅通过一个简单的状态从而控制显隐，在复杂的 modal 中是不够的。</p>
<p>举个例子，我们有个创建新书籍信息的弹窗表单，其中可能有时间，书名等等信息</p>
<p>假如我们所希望的是我们每次弹窗之后，都是一个新的代填写的表单，那么仅仅之有一个控制状态显隐的变量是不够的，<br>我们其实还必须每次都清理掉已经填写过的时间，书名等信息，将那些中间状态都清理掉，这还只是最简单的一中情况，弹窗中存在的变量逻辑越多，需要处理掉的中间状态就会随之增加。<br>这样实在是不如每次都异步创建一个新的弹窗，用完即销毁更加简单直接。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="提取到-body"><a href="#提取到-body" class="headerlink" title="提取到 body"></a>提取到 body</h3><h4 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h4><h4 id="iview-的解决方案"><a href="#iview-的解决方案" class="headerlink" title="iview 的解决方案"></a>iview 的解决方案</h4><h3 id="transfer-dom-指令代码分析"><a href="#transfer-dom-指令代码分析" class="headerlink" title="transfer-dom 指令代码分析"></a>transfer-dom 指令代码分析</h3>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/14/axios问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fszer">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://cloud.githubusercontent.com/assets/18730194/15146790/dd39acee-16ef-11e6-8ee7-093d1ce74fce.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="聆听群山的怒号">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/14/axios问题/" itemprop="url">
                  无知
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-14T09:58:07+08:00">
                2017-05-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/杂谈/" itemprop="url" rel="index">
                    <span itemprop="name">杂谈</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p><img src="https://cloud.githubusercontent.com/assets/18730194/26061582/e9ee9654-39ba-11e7-85d8-16656bd2d68d.png" alt="62885633_p0"></p>
<h2 id="令人蛋疼的问题"><a href="#令人蛋疼的问题" class="headerlink" title="令人蛋疼的问题"></a>令人蛋疼的问题</h2><p>前些天看到一个比较有趣的包，实现了一个命令行工具。其中涉及到数据网络请求部分是用 request 实现的。<br>其中的实现方式还是用了传统 cb ，倒不是说不好，只是我一时起兴想要用 promise 风格的实现来重写一遍。<br>结果用 promise 实现逻辑倒不是难事，反而是其中一个我没有注意的细节害我卡带许久。<br>于是写一篇博客记录一下</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/05/14/axios问题/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/03/如何实现一个滑动消除组件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fszer">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://cloud.githubusercontent.com/assets/18730194/15146790/dd39acee-16ef-11e6-8ee7-093d1ce74fce.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="聆听群山的怒号">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/03/如何实现一个滑动消除组件/" itemprop="url">
                  如何实现一个滑动消除组件
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-03T22:23:00+08:00">
                2017-05-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript-学习/" itemprop="url" rel="index">
                    <span itemprop="name">javascript 学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="如何用原生实现一个滑动消除卡片的组件"><a href="#如何用原生实现一个滑动消除卡片的组件" class="headerlink" title="如何用原生实现一个滑动消除卡片的组件"></a>如何用原生实现一个滑动消除卡片的组件</h1><p>今天看到chrome github 实现的一个通过左右滑动清除子卡片的的组件。感觉有点意思，学习一下<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/05/03/如何实现一个滑动消除组件/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/25/reduce简介/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fszer">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://cloud.githubusercontent.com/assets/18730194/15146790/dd39acee-16ef-11e6-8ee7-093d1ce74fce.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="聆听群山的怒号">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/25/reduce简介/" itemprop="url">
                  reduce 简介
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-25T23:01:51+08:00">
                2017-04-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript-学习/" itemprop="url" rel="index">
                    <span itemprop="name">javascript 学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="reduce-定义"><a href="#reduce-定义" class="headerlink" title="reduce 定义"></a>reduce 定义</h2><p>reduce 在 MDN 里面的定义如下</p>
<blockquote>
<p>reduce() 方法对累加器和数组中的每个元素 (从左到右)应用一个函数，将其减少为单个值。<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/04/25/reduce简介/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/20/【译】为什么说使用 `_.chain` 是个错误/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fszer">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://cloud.githubusercontent.com/assets/18730194/15146790/dd39acee-16ef-11e6-8ee7-093d1ce74fce.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="聆听群山的怒号">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/20/【译】为什么说使用 `_.chain` 是个错误/" itemprop="url">
                  【译】为什么说使用 `_.chain` 是个错误
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-20T19:20:43+08:00">
                2017-02-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="为什么说使用-chain-是个错误"><a href="#为什么说使用-chain-是个错误" class="headerlink" title="为什么说使用 _.chain 是个错误"></a>为什么说使用 <code>_.chain</code> 是个错误</h2><p>将你的代码从<code>_.chain</code>的枷锁中解放出来。</p>
<p>图片来源于Jeremy Booth; 特别要感谢Eric Baer, Brooklyn Zelenka &amp; Jason Trill 他们的无私的帮助和知识;也特别要感谢 John-David Dalton 不仅是因为 lodash 本身，还有他谦虚的指出了这篇文章的一些不准确之处以及介绍了许多有关 lodash 内部工作原理的花边知识。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/02/20/【译】为什么说使用 `_.chain` 是个错误/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/20/让 linting 再一次伟大/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fszer">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://cloud.githubusercontent.com/assets/18730194/15146790/dd39acee-16ef-11e6-8ee7-093d1ce74fce.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="聆听群山的怒号">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/20/让 linting 再一次伟大/" itemprop="url">
                  【译】让 linting 再一次伟大!
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-20T19:20:43+08:00">
                2017-01-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>作为一个前端开发者我总是寻找一些可以使得反馈路径尽可能短的工具，而我相信 linting 会是其中一个。当然，有了 IDE 与文本编辑器的集成你一定用过它们。另一方面，还有那些云端代码质量工具，比如像是 <a href="https://codeclimate.com/">CodeClimate</a> 等一些工具，又或者是你自定义的 CI 工具，因而你大概也有用到。不过在这两者之间有一个小小的夹缝。</p>
<p>想象以下情形：你向代码仓库提交了一个 PR， 里面包含了一些类似检查启用与一些快速提交的代码。几分钟之后，在你已经进入另一个任务状态中的时候，你突然收到一份邮件说 CI 步骤失败了，而且很有可能是因为忘记了分号！切换任务，修复它，提交，等待 CI 通过…… “我希望我可以在提交改动到代码仓库 <em>以前</em> lint 这份代码 ” - 我无数次这样想到。</p>
<p><img src="http://p0.qhimg.com/t0199e4b94cede7a845.png" alt=""></p>
<p>但很可惜的是，即使是在有 IDE 集成 linting 的地方，也没有能阻止我和我的同事在不同的项目中提交了带有 linting 错误的代码。在多数时候这不都是一个大问题，然而在极少数的一些情况下，这会令我在这些提交后，反过来花费数小时去寻找 bug 。明明只要我们不允许推送这些 💩 代码到代码仓库中，这些浪费时间的行为就可以被轻易的阻止！<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/01/20/让 linting 再一次伟大/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/08/23/请拿开你的初级开发者名号/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fszer">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://cloud.githubusercontent.com/assets/18730194/15146790/dd39acee-16ef-11e6-8ee7-093d1ce74fce.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="聆听群山的怒号">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/23/请拿开你的初级开发者名号/" itemprop="url">
                  请把“初级”从你的开发者名号上拿开
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-08-23T22:29:28+08:00">
                2016-08-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>我反对“初级开发者”这个头衔，因为它让我感到相当的困扰。虽然这看起来像是胡言乱语，而且也没有什么意义。但是一个来自推特的发言让我相信这仍有写出来的价值。</p>
<blockquote>
<p>非常反感我们把那些拥有 2年以上开发经验 （一个理论物理学士学位或者十年经验的艺术家）称之为’初级’<br>— Yehuda Katz (@wycats) <a href="https://twitter.com/wycats/status/673913834713706496">December 7, 2015</a></p>
</blockquote>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2016/08/23/请拿开你的初级开发者名号/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/08/21/深层嵌套的Promise链解明/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fszer">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://cloud.githubusercontent.com/assets/18730194/15146790/dd39acee-16ef-11e6-8ee7-093d1ce74fce.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="聆听群山的怒号">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/21/深层嵌套的Promise链解明/" itemprop="url">
                  【译】深层嵌套的Promise链解明
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-08-21T23:53:02+08:00">
                2016-08-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>如果你已经写了一段时间的 JavaScript 代码，你大概会听过像是<strong>回调地狱</strong>或者是<strong>噩梦金字塔</strong> 这类的说法。在几年前 promises 被添加到 JavaScript 中的时候。我记得我阅读到大量博客文章宣称回调地狱这类问题会得到解决。不幸的是，这看法稍微太乐观了些。随着越来越多的网页的 API 变得以 promise 为基础。我们会证明即使是 promise 也不能阻止我们写出过分嵌套且难以阅读的代码。</p>
<p>这些天我在完全基于 promise 的Service Worker 脚本中看到这件事发生了许多次。特别是在那些应当向我们展示 Service Worker 正确使用方法的博客文章跟教程当中。</p>
<p>下面的代码是一个关于如何使用 Serivce Worker 来实现一个网络优先，带缓存回调的离线支持方案的所谓的”基础”例子。<br>就是这个代码（或者是他的一个变形版本）可以在网上的多个教程中找到。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">self.addEventListener(<span class="string">'fetch'</span>, (event) =&gt; &#123;</div><div class="line">  event.respondWith(</div><div class="line">    caches.open(<span class="string">'cache:v1'</span>).then((cache) =&gt; &#123;</div><div class="line">      <span class="keyword">return</span> fetch(event.request).then((response) =&gt; &#123;</div><div class="line">        cache.put(event.request, response.clone());</div><div class="line">        <span class="keyword">return</span> response;</div><div class="line">      &#125;).catch(() =&gt; &#123;</div><div class="line">        <span class="keyword">return</span> cache.match(event.request).then((response) =&gt; &#123;</div><div class="line">          <span class="keyword">return</span> response || Response.error();</div><div class="line">        &#125;);</div><div class="line">      &#125;);</div><div class="line">    &#125;)</div><div class="line">  );</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>嗯，我相信这个代码会在这里被称之为“基础”是经过考虑的，因为这里只有几行代码，并且涉及到概念也不算复杂，但是我要质疑的一点是，这个控制流可以说是任何别的什么，但称不上基础。除非你非常熟悉 <code>Fetch</code> 和 <code>CacheStorage</code> 这两个新API，又或是你对 promises 所有的细微之处有着坚实的理解。不然这个代码大概会让你神思好几秒来弄清楚这些代码到底做了些什么。</p>
<p>从个人经验来说，我在一个星期以前开始第一次捣鼓 Service Worker ：我想要添加一个基础的缓存和离线的分析到这个网站（指的是原作者的blog吧）。但是在我完成我最初的实现之后，我还挺不满意我写的代码的。它并不清晰，也不足以自我说明的的，同时，它看起来相对于我尝试要解决的这个简单问题来说，太过复杂了。</p>
<p>在我花了几个小时去重构代码并认真研究那些新的 API 之后，我得出了一些方案来改善我的代码的可阅读性，因此我想分享出来。这些方案可以归类到一般的软件开发建议，以及最好的实践方案是借力于新的javaScript 语言特性，比如说像是 Async 函数。</p>
<p>注意：我这里不是要指责那些写了 Service Worker 教程的人。我从那些教程中学到了非常多的东西，我认为那些是无法去衡量价值的。而我同样理解在写博客文章的时候，一个简洁的例子的必要性。</p>
<p>这篇文章主要目的是促使那些教程的读者们，去确保他们自己的实现方案有着可读性以及可维护的。从而拒绝那些没有经过全盘理解的，只是简单地从例子模板当中复制粘贴的行为。</p>
<h2 id="这段代码做了什么？"><a href="#这段代码做了什么？" class="headerlink" title="这段代码做了什么？"></a>这段代码做了什么？</h2><p>在我开始谈论如何优化这段代码之前，我想要确保每个人都非常明白地理解了这段代码做了什么。</p>
<p>当添加了一个 <code>fetch</code> 来监听一个 Service Worker 事件的时候，你通常会调用 <code>event.respondWith</code> 并传递一个 promise 来处理一个 <code>Response</code> 对象。但是当你传递一个类似于上面的例子中的 promise 链（带有多级嵌套的<code>then</code> 与<code>catch</code> 调用），其中那些可能发生的 resolution 中的关键就变得相当难以被发现。</p>
<p>这里用最简洁的文字，给出了一个对于上面的代码例子中的，<code>fetch</code> 事件处理方法内部到底发生了什么，一步步渐进式的解释：</p>
<ol>
<li><code>event</code> 对象调用了 <code>respoondWith()</code> 然后传入了一个最终会处理到一个 <code>Response</code> 对象的 promise 链</li>
<li>这个 promise 链开始于打开 <code>cache:v1</code> 这个缓存调用。</li>
<li>一旦这个缓存被打开， 它会让一个 <code>fetch()</code> 去向网络请求由 <code>event.request</code> 指定的请求对象。</li>
<li>如果 <code>fetch()</code> 请求成功：<br> a. 它会将这个网络请求的响应复制一份，放到这个缓存中。<br> b. 它会返回这个响应作为 promise 的 resolves</li>
<li>如果 <code>fetch()</code> 请求失败：<br> a. 它会尝试从这个缓存中寻找一个匹配的请求。<br> b. 如果这个匹配找得到<pre><code>i. 它会返回这个缓存响应作为 promise 的 resolves
</code></pre> c. 如果这个匹配找不到<pre><code>i. 它会将一个通用的 `Responese.error()` 对象作为 promise 的 resolves
</code></pre>我上面提到的<code>responWith()</code> 会得到一个最终 resolves 到一个 <code>Response</code> 对象的 promise。在上面的逻辑之外， resolution 可能发生在三个不同的地方 <code>4.b</code>, <code>5.b.i</code>和 <code>5.c.i</code> 。</li>
</ol>
<h2 id="这个代码该如何被优化"><a href="#这个代码该如何被优化" class="headerlink" title="这个代码该如何被优化"></a>这个代码该如何被优化</h2><p>接下来的每一章都会介绍一个技巧或者一个原理来帮助你的代码变得更加可读的，并最终让你（或者别的人）在将来干活的时候更加容易。这些技巧会从简单的开始，然后逐渐变得越来越复杂。</p>
<h3 id="给变量一个更有描述性名称"><a href="#给变量一个更有描述性名称" class="headerlink" title="给变量一个更有描述性名称"></a>给变量一个更有描述性名称</h3><p>当你在写着 Service Worker 代码的时候，你会发现你在处理相当多的 <code>Requset</code> 和 <code>Response</code> 对象，必须说，在你代码中所有出现这些对象的地方，都只用上面的名称去命名这个做法可能会相当诱人的。并且如果每一个 <code>Request</code> 或者 <code>Response</code> 对象只出现在他们独自的不同的作用域当中的话。我们并没有一个技术上的理由，要去改变他们的命名。</p>
<p>然而，在我们这个Service Worker <code>fetch</code> 例子的案例当中，这里存在着不同的逻辑分支，这些的分支可能会导致两个完全不同类型的响应：一个网络的响应或者是一个缓存的响应。</p>
<p>要告诉阅读代码的人哪个条件会导致哪个结果在，最简单的方法是给每一个 <code>Response</code> 对象一个指明其条件的名字：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">self.addEventListener(<span class="string">'fetch'</span>, (event) =&gt; &#123;</div><div class="line">  event.respondWith(</div><div class="line">    caches.open(<span class="string">'cache:v1'</span>).then((cache) =&gt; &#123;</div><div class="line">      <span class="keyword">return</span> fetch(event.request).then((networkResponse) =&gt; &#123;</div><div class="line">        cache.put(event.request, networkResponse.clone());</div><div class="line">        <span class="keyword">return</span> networkResponse;</div><div class="line">      &#125;).catch(() =&gt; &#123;</div><div class="line">        <span class="keyword">return</span> cache.match(event.request).then((cacheResponse) =&gt; &#123;</div><div class="line">          <span class="keyword">return</span> cacheResponse || Response.error();</div><div class="line">        &#125;);</div><div class="line">      &#125;);</div><div class="line">    &#125;)</div><div class="line">  );</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="避免代码看起来就像一个错误"><a href="#避免代码看起来就像一个错误" class="headerlink" title="避免代码看起来就像一个错误"></a>避免代码看起来就像一个错误</h3><p>如果你看到我们原始例子中的代码的最后五行，这就是你会看到的。请注意，在中间的那一行行末是没有分号的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">          // ...</div><div class="line">        &#125;);</div><div class="line">      &#125;);</div><div class="line">    &#125;)</div><div class="line">  );</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>当我第一次看到这里，我以为这只是一个忘了写分号的失误，但是我错了。</p>
<p>事实上，这个表达式开始于<code>caches.open()</code> 并且这里被分离成自己一行还加上缩进——想必是为了避免在一行里面塞进太多的逻辑。</p>
<p>虽然我是支持那种去分割这段代码为更多可管理的小块的冲动。但如果用这种方法来做，只会使得它看起来像是一个错误（这个分号实在是令人困惑）</p>
<p>如果你有一个非常长/非常复杂的的表达式，让你感觉到需要从视觉上分离它，为什么不<em>实际</em>上去分离它呢：<br>将这个表达式移到别的地方，并把这个表达式的结果分配给一个变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">self.addEventListener(<span class="string">'fetch'</span>, (event) =&gt; &#123;</div><div class="line">  <span class="keyword">const</span> networkOrCacheResponse = caches.open(<span class="string">'cache:v1'</span>).then((cache) =&gt; &#123;</div><div class="line">    <span class="keyword">return</span> fetch(event.request).then((networkResponse) =&gt; &#123;</div><div class="line">      cache.put(event.request, networkResponse.clone());</div><div class="line">      <span class="keyword">return</span> networkResponse;</div><div class="line">    &#125;).catch(() =&gt; &#123;</div><div class="line">      <span class="keyword">return</span> cache.match(event.request).then((cacheResponse) =&gt; &#123;</div><div class="line">        <span class="keyword">return</span> cacheResponse || Response.error();</div><div class="line">      &#125;);</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  event.respondWith(networkOrCacheResponse);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="抽象逻辑单位为单个功能的函数"><a href="#抽象逻辑单位为单个功能的函数" class="headerlink" title="抽象逻辑单位为单个功能的函数"></a>抽象逻辑单位为单个功能的函数</h3><p>将一个复杂的表达式的结果赋值给一个变量，再把它传递给别的方法是非常有利于提高可读性的。但是我们还可以做的更好。</p>
<p>就拿上面的示例代码来说，<code>networkOrCacheResponse</code> 对象只能在这个特定的 <code>fetch</code> 方法当中使用。如果你想要在别的地方使用 <em>网络优先带有缓存回调</em> 的方法，你会需要去重写这段逻辑。</p>
<p>为了解决这个问题，我们可以写一个工具函数来接收一个 <code>Reauest</code>对象，并返回一个会选择请求网络或者缓存响应来处理这request的 promise。这个函数看起来可能会是这样的：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">const</span> getNetworkOrCacheResponse = (request) =&gt; &#123;</div><div class="line">  <span class="keyword">return</span> caches.open(<span class="string">'cache:v1'</span>).then((cache) =&gt; &#123;</div><div class="line">    <span class="keyword">return</span> fetch(request).then((networkResponse) =&gt; &#123;</div><div class="line">      cache.put(request, networkResponse.clone());</div><div class="line">      <span class="keyword">return</span> networkResponse;</div><div class="line">    &#125;).catch(() =&gt; &#123;</div><div class="line">      <span class="keyword">return</span> cache.match(request).then((cacheResponse) =&gt; &#123;</div><div class="line">        <span class="keyword">return</span> cacheResponse || Response.error();</div><div class="line">      &#125;);</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">self.addEventListener(<span class="string">'fetch'</span>, (event) =&gt; &#123;</div><div class="line">  event.respondWith(getNetworkOrCacheResponse(event.request));</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>现在这个方法变得可读多了，但是它依然有些复杂。</p>
<p>你会注意到这里有相当多个层级的 promise 嵌套。当你在某个地方看到非常多的嵌套在一个函数中的时候，这通常意味着这个函数做了太多工作了。换句话说，它的责任太重了。</p>
<p><code>getNeetworkOrCacheResponse</code> 这个函数包含了两个关注点非常分离的逻辑：</p>
<ul>
<li>发出一个网络请求</li>
<li>与缓存互动</li>
</ul>
<p>为了改善这个函数的可阅读性，我们可以抽象出与缓存相关的逻辑，分离到单独一个函数中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> addToCache = (request, networkResponse) =&gt; &#123;</div><div class="line">  <span class="keyword">return</span> caches.open(<span class="string">'cache:v1'</span>)</div><div class="line">    .then((cache) =&gt; cache.put(request, networkResponse.clone()));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> getCacheResponse = (request) =&gt; &#123;</div><div class="line">  <span class="keyword">return</span> caches.open(<span class="string">'cache:v1'</span>).then((cache) =&gt; &#123;</div><div class="line">    <span class="keyword">return</span> cache.match(request);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> getNetworkOrCacheResponse = (request) =&gt; &#123;</div><div class="line">  <span class="keyword">return</span> fetch(request).then((networkResponse) =&gt; &#123;</div><div class="line">    addToCache(request, networkResponse);</div><div class="line">    <span class="keyword">return</span> networkResponse;</div><div class="line">  &#125;).catch(() =&gt; &#123;</div><div class="line">    <span class="keyword">return</span> getCacheResponse(request)</div><div class="line">      .then((cacheResponse) =&gt; cacheResponse || Response.error());</div><div class="line">  &#125;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">self.addEventListener(<span class="string">'fetch'</span>, (event) =&gt; &#123;</div><div class="line">  event.respondWith(getNetworkOrCacheResponse(event.request));</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>如果你比较过这个新的逻辑和一开始的方法。你会注意到一个非常重要的不同。在原始的代码中。第一件发生的事情是调用<code>caches.open()</code>,同时它的调用只会发生一次。在新的代码中，在每一次这个工具函数与缓存打交道的时候都会调用<code>caches.open()</code> 。</p>
<p>第一眼看到它，可能会让人觉得这个抽象最终是做了多于的事。而实际上这是对原始代码的一种优化。这一点在我开始分离代码之后才发现到。</p>
<p>试想一下在 Service Worker 成功请求到一个网络响应的情况。这是最常见的情形，因此我们应当优化它（即尽可能快的得到响应给用户）。在原始的代码中。第一步逻辑是打开一个缓存，然后只在缓存开着的时候才会去请求网络响应。</p>
<p>这绝对不是必要的。当我们真的需要在网络响应的情形中去写一个缓存事件的时候，写入的过程并不需要阻塞给用户的响应。这两件事可以简单的并行化。</p>
<p>如果你好奇为什么将函数写成单责任的函数，是如此重要的事情。这里有两条基础的理由：</p>
<ul>
<li>这样函数会更加可重用（一个函数所负的责任越多，它就越是一个针对特定使用场景的具体方法）</li>
<li>这样的函数更加容易被测试。（只做各自的一件事打的N个方法，可以被N个测试所测试。相比之下，一个函数做了N件事情通常会需要去测试 N！种可能输出）</li>
</ul>
<h3 id="使用-Async-函数来去除完全嵌套"><a href="#使用-Async-函数来去除完全嵌套" class="headerlink" title="使用 Async 函数来去除完全嵌套"></a>使用 Async 函数来去除完全嵌套</h3><p>或许改善复杂的 promise 代码的最好途径就是使用 async 函数，一个新的 javascript 特性，被用于让异步逻辑读起来更像同步代码。</p>
<p>Async 函数需要通过新的 <code>async</code> 关键字来声明,为了替代立即返回的值，他们会返回一个 最终会 reslove 到这个函数的返回值的 promise 对象。</p>
<p>在一个 async 函数的内部，你通常会找到一个或多个 <code>await</code> 关键字。<code>await</code> 关键字会提前设置置一个 promise （或者是一个解析为 promise的表达式），当解析器解析到这个<code>await</code>关键字，它就会停止执行这个函数，直到这个 promise 被处理掉。一旦这个promise 被处理掉，这个等待已久的表达式就会返回那个promise 处理的结果。</p>
<p>说明得更加清楚，试想想上面一个章节定义的<code>getNetworkOrCacheResponse()</code> 。如果它是一个 async 函数的话，就是他该有的样子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> getNetworkOrCacheResponse = <span class="keyword">async</span> (request) =&gt; &#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">const</span> networkResponse = <span class="keyword">await</span> fetch(request);</div><div class="line">    addToCache(request, networkResponse);</div><div class="line">    <span class="keyword">return</span> networkResponse;</div><div class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</div><div class="line">    <span class="keyword">const</span> cacheResponse = <span class="keyword">await</span> getCacheResponse(request);</div><div class="line">    <span class="keyword">return</span> cacheResponse || Response.error();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这个函数的 <code>async</code>版本中，有这样一些需要注意的重要事情。</p>
<ul>
<li>你可以在 <code>try/catch</code> 作用域中使用 <code>.then()/.catch()</code> 链，并且这里处理错误异常的方法就像在普通的一个<code>try/catch</code>块中那样。</li>
<li>由于<code>await</code>停止了执行并等待一个 promise的返回，那些原本多重层级的嵌套现在可以像是顺序执行那样响应了，最上面哪一行定义了这个表达式（没有用到嵌套）。</li>
<li>由于 一个 <code>async</code> 函数是一个去 resolve 它要返回的值的语法糖，这使得当一个promise 响应发生的时候变得更加清晰。如果是用嵌套的promise 链，它的响应可能会更加模糊些。</li>
</ul>
<p>这个优化相当之有意义！他们让你的代码更加易于阅读和书写。</p>
<h3 id="立即使用-async-函数"><a href="#立即使用-async-函数" class="headerlink" title="立即使用 async 函数"></a>立即使用 async 函数</h3><p>Async 函数已经出现了一段时间了，你可以通过 Babel 去编译 Async 为 ES5代码。然而，为了使用编译过的代码，你也需要引入 <code>babel-plyfill</code> 库（其中的带有 Facebook的环境运行时）。</p>
<p>这对一些项目来说这是可能不太能被接受的，被添加的polyfill的代码大小对于一个50行的 Service Worker 脚本来说是不可接受的高（在我的测试中它添加了将近60k）</p>
<p>幸运的是，当它使用于 Service Worker 脚本的时候，这里还有别的方法。</p>
<p>所有的浏览器都支持 Service Worker 的同时也会支持到 es2015 的特性（特别是他们会支持 generators），你可以避免添加运行时并且只用单个Babel 转化器：<code>async-to-generator</code> 来编译你的代码。</p>
<p>在我这个站点的 Service Worker 脚本中，使用<code>async-to-generator</code> 转化器仅仅只添加额外的258 字节，并且由于我已经使用了 browserify去加载依赖，我可以无脑地使用 async 函数！</p>
<h2 id="都用起来"><a href="#都用起来" class="headerlink" title="都用起来"></a>都用起来</h2><p>有了这里提到的那么多的优化方法，比较一下原始的代码和重构后的代码吧</p>
<p>原来的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">self.addEventListener(<span class="string">'fetch'</span>, (event) =&gt; &#123;</div><div class="line">  event.respondWith(</div><div class="line">    caches.open(<span class="string">'cache:v1'</span>).then((cache) =&gt; &#123;</div><div class="line">      <span class="keyword">return</span> fetch(event.request).then((response) =&gt; &#123;</div><div class="line">        cache.put(event.request, response.clone());</div><div class="line">        <span class="keyword">return</span> response;</div><div class="line">      &#125;).catch(() =&gt; &#123;</div><div class="line">        <span class="keyword">return</span> cache.match(event.request).then((response) =&gt; &#123;</div><div class="line">          <span class="keyword">return</span> response || Response.error();</div><div class="line">        &#125;);</div><div class="line">      &#125;);</div><div class="line">    &#125;)</div><div class="line">  );</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>重构以后：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> addToCache = <span class="keyword">async</span> (request, networkResponse) =&gt; &#123;</div><div class="line">  <span class="keyword">const</span> cache = <span class="keyword">await</span> caches.open(<span class="string">'cache:v1'</span>);</div><div class="line">  cache.put(request, networkResponse.clone());</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> getCacheResponse = <span class="keyword">async</span> (request) =&gt; &#123;</div><div class="line">  <span class="keyword">const</span> cache = <span class="keyword">await</span> caches.open(<span class="string">'cache:v1'</span>);</div><div class="line">  <span class="keyword">const</span> cachedResponse = <span class="keyword">await</span> cache.match(request);</div><div class="line">  <span class="keyword">return</span> cachedResponse;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> getNetworkOrCacheResponse = <span class="keyword">async</span> (request) =&gt; &#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">const</span> networkResponse = <span class="keyword">await</span> fetch(request);</div><div class="line">    addToCache(request, networkResponse);</div><div class="line">    <span class="keyword">return</span> networkResponse;</div><div class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</div><div class="line">    <span class="keyword">const</span> cacheResponse = <span class="keyword">await</span> getCacheResponse(request);</div><div class="line">    <span class="keyword">return</span> cacheResponse || Response.error();</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">self.addEventListener(<span class="string">'fetch'</span>, (event) =&gt; &#123;</div><div class="line">  event.respondWith(getNetworkOrCacheResponse(event.request));</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>虽然重构的版本更加长还包含了更多的代码，但是它毫无疑问更易于阅读和理解，这意味着这段代码在将来更新起来更加容易。这也更加模块化，从而更易于被测试和到其他地方复用。</p>
<p>这篇文章介绍了几个概念和方法去帮助你重构复杂的，基于promise的代码为独立可复用的部分。希望这些被介绍到的技术是会有用的。至少，我希望我能促使你去努力让你的代码尽可能地具有可读性和可维护性。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/08/05/build-your-first-thing-with-web-assembly/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fszer">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://cloud.githubusercontent.com/assets/18730194/15146790/dd39acee-16ef-11e6-8ee7-093d1ce74fce.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="聆听群山的怒号">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/05/build-your-first-thing-with-web-assembly/" itemprop="url">
                  【翻译】建立你的第一个 WebAssembly 应用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-08-05T20:38:48+08:00">
                2016-08-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p><img src="https://cloud.githubusercontent.com/assets/18730194/17642741/9745a406-6184-11e6-86ae-85a97cc6c3d7.png" alt="58373003_p0"></p>
<hr>
<p>当我第一次听见 WebAssembly 消息的时候就觉得它非常酷，我迫不及待地想要开始尝试使用它。然而当我不久之后开始使用 WebAssembly 的时候 ，它给我我最大的感受却是令人泄气。这篇文章的目的就是让你避免这些令人沮丧的部分。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2016/08/05/build-your-first-thing-with-web-assembly/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://cloud.githubusercontent.com/assets/18730194/15146790/dd39acee-16ef-11e6-8ee7-093d1ce74fce.png"
               alt="Fszer" />
          <p class="site-author-name" itemprop="name">Fszer</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">29</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fszer</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
